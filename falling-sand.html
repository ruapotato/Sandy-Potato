<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Falling Sand</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            display: flex;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            overflow: hidden;
        }
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
        h1 {
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
            font-size: 28px;
            margin-bottom: 8px;
            letter-spacing: 2px;
        }
        .canvas-container {
            position: relative;
            border: 3px solid #333;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0,0,0,0.5), inset 0 0 50px rgba(0,0,0,0.3);
        }
        canvas {
            display: block;
            cursor: crosshair;
            background: #000;
        }
        .sidebar {
            width: 220px;
            height: 100vh;
            background: rgba(20, 20, 40, 0.95);
            border-left: 2px solid #333;
            padding: 10px;
            padding-bottom: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex-shrink: 0;
        }
        .sidebar::-webkit-scrollbar {
            width: 8px;
        }
        .sidebar::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.3);
        }
        .category {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            padding: 8px;
        }
        .category-title {
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
        }
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
        }
        .btn-grid button {
            padding: 6px 4px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 9px;
            font-weight: bold;
            transition: all 0.15s;
            text-transform: uppercase;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        .btn-grid button:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }
        .btn-grid button.active {
            box-shadow: 0 0 8px 2px rgba(255,255,255,0.7);
            transform: scale(1.05);
        }
        /* Element colors */
        .btn-sand { background: linear-gradient(135deg, #e6c35c, #c9a83e); color: #333; }
        .btn-dirt { background: linear-gradient(135deg, #8B4513, #6b3510); color: #fff; }
        .btn-gravel { background: linear-gradient(135deg, #808080, #606060); color: #fff; }
        .btn-snow { background: linear-gradient(135deg, #f0f8ff, #d0e8f0); color: #333; }
        .btn-gunpowder { background: linear-gradient(135deg, #3f3f3f, #1f1f1f); color: #fff; }
        .btn-salt { background: linear-gradient(135deg, #fafafa, #e0e0e0); color: #333; }
        .btn-ash { background: linear-gradient(135deg, #696969, #494949); color: #fff; }
        .btn-ember { background: linear-gradient(135deg, #ff4500, #cc3300); color: #fff; }
        .btn-coal { background: linear-gradient(135deg, #1a1a1a, #0a0a0a); color: #fff; }
        .btn-glass-powder { background: linear-gradient(135deg, #b8d4e3, #90b8d0); color: #333; }
        .btn-water { background: linear-gradient(135deg, #4a90d9, #2a70b9); color: #fff; }
        .btn-oil { background: linear-gradient(135deg, #5a4738, #3a2718); color: #fff; }
        .btn-lava { background: linear-gradient(135deg, #ff4500, #cc2200); color: #fff; }
        .btn-acid { background: linear-gradient(135deg, #7fff00, #5fdd00); color: #333; }
        .btn-poison { background: linear-gradient(135deg, #9b30ff, #7b00db); color: #fff; }
        .btn-mud { background: linear-gradient(135deg, #6c5043, #4c3023); color: #fff; }
        .btn-mercury { background: linear-gradient(135deg, #c0c0c0, #909090); color: #333; }
        .btn-nitroglycerin { background: linear-gradient(135deg, #ffe4b5, #ddc495); color: #333; }
        .btn-stone { background: linear-gradient(135deg, #666, #444); color: #fff; }
        .btn-wood { background: linear-gradient(135deg, #a0522d, #704010); color: #fff; }
        .btn-metal { background: linear-gradient(135deg, #81898E, #515961); color: #fff; }
        .btn-glass { background: linear-gradient(135deg, #add8e6, #8db8c6); color: #333; }
        .btn-ice { background: linear-gradient(135deg, #c0f0f6, #90c0d6); color: #333; }
        .btn-brick { background: linear-gradient(135deg, #cb4154, #9b2134); color: #fff; }
        .btn-obsidian { background: linear-gradient(135deg, #2a1a4e, #0a001e); color: #fff; }
        .btn-diamond { background: linear-gradient(135deg, #b9f2ff, #89d2ef); color: #333; }
        .btn-titanium { background: linear-gradient(135deg, #878681, #676661); color: #fff; }
        .btn-fire { background: linear-gradient(135deg, #ff6b35, #ff2200); color: #fff; }
        .btn-steam { background: linear-gradient(135deg, #dcdcdc, #b0b0b0); color: #333; }
        .btn-smoke { background: linear-gradient(135deg, #4a4a4a, #2a2a2a); color: #fff; }
        .btn-gas { background: linear-gradient(135deg, #90ee90, #60be60); color: #333; }
        .btn-plasma { background: linear-gradient(135deg, #ff00ff, #cc00cc); color: #fff; }
        .btn-lightning { background: linear-gradient(135deg, #ffff00, #cccc00); color: #333; }
        .btn-plant { background: linear-gradient(135deg, #228b22, #126a12); color: #fff; }
        .btn-seed { background: linear-gradient(135deg, #556b2f, #354b0f); color: #fff; }
        .btn-vine { background: linear-gradient(135deg, #2e8b57, #0e6b37); color: #fff; }
        .btn-fungus { background: linear-gradient(135deg, #9370db, #7350bb); color: #fff; }
        .btn-algae { background: linear-gradient(135deg, #3cb371, #1c9351); color: #fff; }
        .btn-bacteria { background: linear-gradient(135deg, #adff2f, #8ddf0f); color: #333; }
        .btn-clone { background: linear-gradient(135deg, #ff69b4, #df4994); color: #fff; }
        .btn-void { background: linear-gradient(135deg, #0a0a0a, #000); color: #fff; border: 1px solid #333; }
        .btn-fuse { background: linear-gradient(135deg, #ffd700, #ddb700); color: #333; }
        .btn-tnt { background: linear-gradient(135deg, #ff0000, #cc0000); color: #fff; }
        .btn-c4 { background: linear-gradient(135deg, #c4c400, #a4a400); color: #333; }
        .btn-nuke { background: linear-gradient(135deg, #00ff00, #00cc00); color: #333; }
        .btn-firework { background: linear-gradient(135deg, #ff1493, #cc0073); color: #fff; }
        .btn-laser { background: linear-gradient(135deg, #ff0000, #990000); color: #fff; }
        .btn-electricity { background: linear-gradient(135deg, #00bfff, #0090cc); color: #fff; }
        .btn-magnet { background: linear-gradient(135deg, #b22222, #8b0000); color: #fff; }
        .btn-antigravity { background: linear-gradient(135deg, #da70d6, #ba50b6); color: #fff; }
        .btn-blackhole { background: radial-gradient(circle, #1a0a2e, #000); color: #fff; }
        .btn-whitehole { background: radial-gradient(circle, #fff, #ccc); color: #333; }
        .btn-portal-a { background: linear-gradient(135deg, #ff8c00, #cc6c00); color: #fff; }
        .btn-portal-b { background: linear-gradient(135deg, #00bfff, #008fcc); color: #fff; }
        .btn-stickman { background: linear-gradient(135deg, #ffcc99, #cc9966); color: #333; }
        .btn-erase { background: linear-gradient(135deg, #444, #222); color: #fff; border: 2px solid #888; }
        .btn-clear { background: linear-gradient(135deg, #c0392b, #962b20); color: #fff; }
        .settings {
            background: rgba(30, 30, 50, 0.8);
            border-radius: 6px;
            padding: 8px;
        }
        .settings label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 11px;
            margin-bottom: 6px;
        }
        .settings input[type="range"] {
            width: 80px;
        }
        .settings input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        .stats {
            font-size: 10px;
            color: #666;
            text-align: center;
            padding: 4px;
        }
        .controls-info {
            font-size: 9px;
            color: #555;
            text-align: center;
            line-height: 1.4;
            margin-top: 8px;
        }
        .stickman-controls {
            background: rgba(50, 50, 70, 0.8);
            border-radius: 6px;
            padding: 8px;
            font-size: 10px;
        }
        .stickman-controls h3 {
            font-size: 11px;
            color: #ffd700;
            margin-bottom: 6px;
        }
        .key {
            display: inline-block;
            background: #333;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 2px 5px;
            font-family: monospace;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <div class="main-area">
        <h1>ULTIMATE FALLING SAND</h1>
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div class="stats" id="stats">Particles: 0 | Stickmen: 0 | FPS: 0</div>
    </div>

    <div class="sidebar">
        <div class="category">
            <div class="category-title">Powders</div>
            <div class="btn-grid">
                <button class="btn-sand active" data-type="SAND">Sand</button>
                <button class="btn-dirt" data-type="DIRT">Dirt</button>
                <button class="btn-gravel" data-type="GRAVEL">Gravel</button>
                <button class="btn-snow" data-type="SNOW">Snow</button>
                <button class="btn-gunpowder" data-type="GUNPOWDER">Gunpowder</button>
                <button class="btn-salt" data-type="SALT">Salt</button>
                <button class="btn-ash" data-type="ASH">Ash</button>
                <button class="btn-ember" data-type="EMBER">Ember</button>
                <button class="btn-coal" data-type="COAL">Coal</button>
                <button class="btn-glass-powder" data-type="GLASS_POWDER">Glass Pwd</button>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Liquids</div>
            <div class="btn-grid">
                <button class="btn-water" data-type="WATER">Water</button>
                <button class="btn-oil" data-type="OIL">Oil</button>
                <button class="btn-lava" data-type="LAVA">Lava</button>
                <button class="btn-acid" data-type="ACID">Acid</button>
                <button class="btn-poison" data-type="POISON">Poison</button>
                <button class="btn-mud" data-type="MUD">Mud</button>
                <button class="btn-mercury" data-type="MERCURY">Mercury</button>
                <button class="btn-nitroglycerin" data-type="NITRO">Nitro</button>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Solids</div>
            <div class="btn-grid">
                <button class="btn-stone" data-type="STONE">Stone</button>
                <button class="btn-wood" data-type="WOOD">Wood</button>
                <button class="btn-metal" data-type="METAL">Metal</button>
                <button class="btn-glass" data-type="GLASS">Glass</button>
                <button class="btn-ice" data-type="ICE">Ice</button>
                <button class="btn-brick" data-type="BRICK">Brick</button>
                <button class="btn-obsidian" data-type="OBSIDIAN">Obsidian</button>
                <button class="btn-diamond" data-type="DIAMOND">Diamond</button>
                <button class="btn-titanium" data-type="TITANIUM">Titanium</button>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Gas & Energy</div>
            <div class="btn-grid">
                <button class="btn-fire" data-type="FIRE">Fire</button>
                <button class="btn-steam" data-type="STEAM">Steam</button>
                <button class="btn-smoke" data-type="SMOKE">Smoke</button>
                <button class="btn-gas" data-type="GAS">Toxic Gas</button>
                <button class="btn-plasma" data-type="PLASMA">Plasma</button>
                <button class="btn-lightning" data-type="LIGHTNING">Lightning</button>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Life</div>
            <div class="btn-grid">
                <button class="btn-plant" data-type="PLANT">Plant</button>
                <button class="btn-seed" data-type="SEED">Seed</button>
                <button class="btn-vine" data-type="VINE">Vine</button>
                <button class="btn-fungus" data-type="FUNGUS">Fungus</button>
                <button class="btn-algae" data-type="ALGAE">Algae</button>
                <button class="btn-bacteria" data-type="BACTERIA">Bacteria</button>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Explosives</div>
            <div class="btn-grid">
                <button class="btn-fuse" data-type="FUSE">Fuse</button>
                <button class="btn-tnt" data-type="TNT">TNT</button>
                <button class="btn-c4" data-type="C4">C4</button>
                <button class="btn-nuke" data-type="NUKE">Nuke</button>
                <button class="btn-firework" data-type="FIREWORK">Firework</button>
                <button class="btn-laser" data-type="LASER">Laser</button>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Special</div>
            <div class="btn-grid">
                <button class="btn-clone" data-type="CLONE">Clone</button>
                <button class="btn-void" data-type="VOID">Void</button>
                <button class="btn-electricity" data-type="ELECTRICITY">Electric</button>
                <button class="btn-magnet" data-type="MAGNET">Magnet</button>
                <button class="btn-antigravity" data-type="ANTIGRAVITY">Anti-Grav</button>
                <button class="btn-blackhole" data-type="BLACKHOLE">Black Hole</button>
                <button class="btn-whitehole" data-type="WHITEHOLE">White Hole</button>
                <button class="btn-portal-a" data-type="PORTAL_A">Portal A</button>
                <button class="btn-portal-b" data-type="PORTAL_B">Portal B</button>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Characters</div>
            <div class="btn-grid">
                <button class="btn-stickman" data-type="STICKMAN">Stickman</button>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Tools</div>
            <div class="btn-grid">
                <button class="btn-erase" data-type="EMPTY">Erase</button>
                <button class="btn-clear" id="btn-clear">Clear All</button>
            </div>
        </div>

        <div class="settings">
            <label>Brush: <span id="brush-value">5</span>
                <input type="range" id="brush-slider" min="1" max="25" value="5">
            </label>
            <label>Sound
                <input type="checkbox" id="sound-toggle" checked>
            </label>
            <label>Pause
                <input type="checkbox" id="pause-toggle">
            </label>
        </div>

        <div class="stickman-controls">
            <h3>Stickman Controls</h3>
            <p><span class="key">WASD</span> or <span class="key">Arrows</span> Move</p>
            <p><span class="key">Space</span> Jump</p>
            <p><span class="key">Tab</span> Switch stickman</p>
        </div>

        <div class="controls-info">
            Scroll to resize brush<br>
            P to pause simulation
        </div>
    </div>

    <script>
        // ============ AUDIO ENGINE ============
        class SoundEngine {
            constructor() {
                this.enabled = true;
                this.ctx = null;
                this.initialized = false;
                this.lastPlayed = {};
                this.cooldown = 50;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.log('Audio not supported');
                }
            }

            canPlay(sound) {
                const now = Date.now();
                if (this.lastPlayed[sound] && now - this.lastPlayed[sound] < this.cooldown) {
                    return false;
                }
                this.lastPlayed[sound] = now;
                return true;
            }

            play(type, volume = 0.3) {
                if (!this.enabled || !this.initialized || !this.canPlay(type)) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                const now = this.ctx.currentTime;
                gain.gain.setValueAtTime(volume, now);

                switch (type) {
                    case 'sand':
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(100 + Math.random() * 50, now);
                        gain.gain.exponentialDecayTo = 0.01;
                        gain.gain.setValueAtTime(volume * 0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                        osc.start(now);
                        osc.stop(now + 0.05);
                        break;

                    case 'water':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400 + Math.random() * 200, now);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                        gain.gain.setValueAtTime(volume * 0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;

                    case 'fire':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(80 + Math.random() * 40, now);
                        gain.gain.setValueAtTime(volume * 0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                        break;

                    case 'explosion':
                        // Noise burst
                        const bufferSize = this.ctx.sampleRate * 0.3;
                        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < bufferSize; i++) {
                            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
                        }
                        const noise = this.ctx.createBufferSource();
                        noise.buffer = buffer;
                        const noiseGain = this.ctx.createGain();
                        noise.connect(noiseGain);
                        noiseGain.connect(this.ctx.destination);
                        noiseGain.gain.setValueAtTime(volume, now);
                        noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                        noise.start(now);
                        return;

                    case 'steam':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(2000 + Math.random() * 500, now);
                        gain.gain.setValueAtTime(volume * 0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;

                    case 'electric':
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(1000 + Math.random() * 1000, now);
                        osc.frequency.setValueAtTime(500 + Math.random() * 500, now + 0.02);
                        osc.frequency.setValueAtTime(2000 + Math.random() * 500, now + 0.04);
                        gain.gain.setValueAtTime(volume * 0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                        osc.start(now);
                        osc.stop(now + 0.08);
                        break;

                    case 'portal':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                        gain.gain.setValueAtTime(volume * 0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                        break;

                    case 'laser':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(1500, now);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                        gain.gain.setValueAtTime(volume * 0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;

                    case 'firework':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(800, now);
                        osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                        gain.gain.setValueAtTime(volume * 0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;

                    case 'jump':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(150, now);
                        osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                        gain.gain.setValueAtTime(volume * 0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                        break;

                    case 'step':
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(80 + Math.random() * 20, now);
                        gain.gain.setValueAtTime(volume * 0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
                        osc.start(now);
                        osc.stop(now + 0.03);
                        break;

                    case 'acid':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(300 + Math.random() * 100, now);
                        gain.gain.setValueAtTime(volume * 0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                        osc.start(now);
                        osc.stop(now + 0.08);
                        break;

                    case 'blackhole':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(50, now);
                        osc.frequency.setValueAtTime(30, now + 0.1);
                        gain.gain.setValueAtTime(volume * 0.4, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;

                    default:
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(440, now);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                }
            }
        }

        const sound = new SoundEngine();

        // Initialize audio on first interaction
        document.addEventListener('click', () => sound.init(), { once: true });
        document.addEventListener('keydown', () => sound.init(), { once: true });

        // ============ MAIN GAME ============
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const CELL_SIZE = 3;
        const WIDTH = 300;
        const HEIGHT = 220;
        canvas.width = WIDTH * CELL_SIZE;
        canvas.height = HEIGHT * CELL_SIZE;

        // Particle types
        const T = {
            EMPTY: 0,
            // Powders (1-19)
            SAND: 1, DIRT: 2, GRAVEL: 3, SNOW: 4, GUNPOWDER: 5,
            SALT: 6, ASH: 7, EMBER: 8, COAL: 9, GLASS_POWDER: 10,
            // Liquids (20-39)
            WATER: 20, OIL: 21, LAVA: 22, ACID: 23, POISON: 24,
            MUD: 25, MERCURY: 26, NITRO: 27,
            // Solids (40-59)
            STONE: 40, WOOD: 41, METAL: 42, GLASS: 43, ICE: 44,
            BRICK: 45, OBSIDIAN: 46, DIAMOND: 47, TITANIUM: 48,
            // Gas (60-79)
            FIRE: 60, STEAM: 61, SMOKE: 62, GAS: 63, PLASMA: 64, LIGHTNING: 65,
            // Life (80-99)
            PLANT: 80, SEED: 81, VINE: 82, FUNGUS: 83, ALGAE: 84, BACTERIA: 85,
            // Explosives (100-119)
            FUSE: 100, TNT: 101, C4: 102, NUKE: 103, FIREWORK: 104, LASER: 105,
            // Special (120-139)
            CLONE: 120, VOID: 121, ELECTRICITY: 122, MAGNET: 123,
            ANTIGRAVITY: 124, BLACKHOLE: 125, WHITEHOLE: 126,
            PORTAL_A: 127, PORTAL_B: 128,
            // Characters
            STICKMAN: 200
        };

        // Colors
        const COLORS = {
            [T.EMPTY]: null,
            [T.SAND]: ['#e6c35c', '#d4b24a', '#f0d068', '#c9a83e'],
            [T.DIRT]: ['#8B4513', '#7a3d10', '#9c4d16', '#6b3510'],
            [T.GRAVEL]: ['#808080', '#707070', '#909090', '#686868'],
            [T.SNOW]: ['#f0f8ff', '#e8f0f7', '#ffffff', '#e0e8ef'],
            [T.GUNPOWDER]: ['#2f2f2f', '#252525', '#393939', '#1f1f1f'],
            [T.SALT]: ['#fafafa', '#f0f0f0', '#ffffff', '#e8e8e8'],
            [T.ASH]: ['#696969', '#5f5f5f', '#737373', '#555555'],
            [T.EMBER]: ['#ff4500', '#ff6a00', '#ff2200', '#ff8c00'],
            [T.COAL]: ['#1a1a1a', '#0f0f0f', '#252525', '#101010'],
            [T.GLASS_POWDER]: ['#b8d4e3', '#a8c4d3', '#c8e4f3', '#98b4c3'],
            [T.WATER]: ['#4a90d9', '#3a80c9', '#5aa0e9', '#2a70b9'],
            [T.OIL]: ['#4a3728', '#3a2718', '#5a4738', '#2a1708'],
            [T.LAVA]: ['#ff4500', '#ff6600', '#ff2200', '#cc3300'],
            [T.ACID]: ['#7fff00', '#6fee00', '#8fff10', '#5fdd00'],
            [T.POISON]: ['#9b30ff', '#8b20ef', '#ab40ff', '#7b10df'],
            [T.MUD]: ['#5c4033', '#4c3023', '#6c5043', '#3c2013'],
            [T.MERCURY]: ['#c0c0c0', '#d0d0d0', '#b0b0b0', '#e0e0e0'],
            [T.NITRO]: ['#ffe4b5', '#efd4a5', '#fff4c5', '#dfc495'],
            [T.STONE]: ['#666666', '#5a5a5a', '#727272', '#4e4e4e'],
            [T.WOOD]: ['#8b4513', '#7b3503', '#9b5523', '#6b2503'],
            [T.METAL]: ['#71797E', '#616971', '#818991', '#515961'],
            [T.GLASS]: ['#add8e6', '#9dc8d6', '#bde8f6', '#8db8c6'],
            [T.ICE]: ['#b0e0e6', '#a0d0d6', '#c0f0f6', '#90c0c6'],
            [T.BRICK]: ['#cb4154', '#bb3144', '#db5164', '#ab2134'],
            [T.OBSIDIAN]: ['#1a0a2e', '#0a001e', '#2a1a3e', '#10051e'],
            [T.DIAMOND]: ['#b9f2ff', '#a9e2ef', '#c9ffff', '#99d2df'],
            [T.TITANIUM]: ['#878681', '#777671', '#979691', '#676661'],
            [T.FIRE]: ['#ff6b35', '#ff8c00', '#ff4500', '#ffd700', '#ff0000'],
            [T.STEAM]: ['#dcdcdc', '#cccccc', '#ececec', '#c0c0c0'],
            [T.SMOKE]: ['#3a3a3a', '#2a2a2a', '#4a4a4a', '#1a1a1a'],
            [T.GAS]: ['#90ee90', '#80de80', '#a0fea0', '#70ce70'],
            [T.PLASMA]: ['#ff00ff', '#ff44ff', '#cc00cc', '#ff88ff'],
            [T.LIGHTNING]: ['#ffff00', '#ffffaa', '#ffff44', '#ffffff'],
            [T.PLANT]: ['#228b22', '#1a7a1a', '#2a9b2a', '#126a12'],
            [T.SEED]: ['#556b2f', '#455b1f', '#657b3f', '#354b0f'],
            [T.VINE]: ['#2e8b57', '#1e7b47', '#3e9b67', '#0e6b37'],
            [T.FUNGUS]: ['#9370db', '#8360cb', '#a380eb', '#7350bb'],
            [T.ALGAE]: ['#3cb371', '#2ca361', '#4cc381', '#1c9351'],
            [T.BACTERIA]: ['#adff2f', '#9def1f', '#bdff3f', '#8ddf0f'],
            [T.FUSE]: ['#ffd700', '#eec700', '#ffdd00', '#ddb700'],
            [T.TNT]: ['#ff0000', '#ee0000', '#ff1010', '#dd0000'],
            [T.C4]: ['#c4c400', '#b4b400', '#d4d400', '#a4a400'],
            [T.NUKE]: ['#00ff00', '#00ee00', '#00ff44', '#00dd00'],
            [T.FIREWORK]: ['#ff1493', '#ff0080', '#ff44aa', '#ee0073'],
            [T.LASER]: ['#ff0000', '#ff3333', '#cc0000', '#ff6666'],
            [T.CLONE]: ['#ff69b4', '#ff59a4', '#ff79c4', '#ff4994'],
            [T.VOID]: ['#000000', '#0a0a0a', '#050505', '#101010'],
            [T.ELECTRICITY]: ['#00bfff', '#00dfff', '#009fdf', '#44cfff'],
            [T.MAGNET]: ['#b22222', '#a01010', '#c23232', '#901010'],
            [T.ANTIGRAVITY]: ['#da70d6', '#ca60c6', '#ea80e6', '#ba50b6'],
            [T.BLACKHOLE]: ['#0a0010', '#000005', '#150020', '#05000a'],
            [T.WHITEHOLE]: ['#ffffff', '#f8f8ff', '#fffff8', '#f0f0ff'],
            [T.PORTAL_A]: ['#ff8c00', '#ff7c00', '#ff9c10', '#ee7c00'],
            [T.PORTAL_B]: ['#00bfff', '#00afef', '#10cfff', '#009fdf'],
        };

        // Particle properties
        const DENSITY = {
            [T.STEAM]: 1, [T.SMOKE]: 2, [T.GAS]: 2, [T.FIRE]: 3,
            [T.OIL]: 5, [T.NITRO]: 6, [T.WATER]: 10, [T.POISON]: 11,
            [T.ACID]: 12, [T.MUD]: 15, [T.LAVA]: 20, [T.MERCURY]: 50,
            [T.SAND]: 30, [T.SALT]: 30, [T.ASH]: 25, [T.SNOW]: 20,
            [T.DIRT]: 35, [T.GRAVEL]: 40, [T.GUNPOWDER]: 30, [T.EMBER]: 28,
            [T.SEED]: 25, [T.COAL]: 32, [T.GLASS_POWDER]: 35,
        };

        const IS_POWDER = new Set([T.SAND, T.DIRT, T.GRAVEL, T.SNOW, T.GUNPOWDER, T.SALT, T.ASH, T.EMBER, T.SEED, T.COAL, T.GLASS_POWDER]);
        const IS_LIQUID = new Set([T.WATER, T.OIL, T.LAVA, T.ACID, T.POISON, T.MUD, T.MERCURY, T.NITRO]);
        const IS_GAS = new Set([T.FIRE, T.STEAM, T.SMOKE, T.GAS, T.PLASMA]);
        const IS_SOLID = new Set([T.STONE, T.WOOD, T.METAL, T.GLASS, T.ICE, T.BRICK, T.OBSIDIAN, T.DIAMOND, T.TITANIUM, T.PLANT, T.VINE, T.FUNGUS, T.CLONE, T.VOID, T.FUSE, T.TNT, T.C4, T.NUKE, T.MAGNET, T.PORTAL_A, T.PORTAL_B]);
        const IS_FLAMMABLE = new Set([T.WOOD, T.OIL, T.GUNPOWDER, T.PLANT, T.VINE, T.FUSE, T.TNT, T.C4, T.NUKE, T.GAS, T.FUNGUS, T.COAL, T.NITRO, T.FIREWORK]);
        const IS_EXPLOSIVE = new Set([T.GUNPOWDER, T.TNT, T.C4, T.NUKE, T.GAS, T.NITRO, T.FIREWORK]);
        const IS_CONDUCTIVE = new Set([T.METAL, T.WATER, T.MERCURY, T.TITANIUM]);
        const ACID_IMMUNE = new Set([T.GLASS, T.OBSIDIAN, T.VOID, T.ACID, T.DIAMOND, T.TITANIUM]);
        const HEAT_SOURCE = new Set([T.FIRE, T.LAVA, T.EMBER, T.PLASMA, T.LIGHTNING]);

        // Grid
        let grid = new Uint8Array(WIDTH * HEIGHT);
        let nextGrid = new Uint8Array(WIDTH * HEIGHT);
        let updated = new Uint8Array(WIDTH * HEIGHT);
        let lifetime = new Uint16Array(WIDTH * HEIGHT);

        // State
        let currentType = T.SAND;
        let brushSize = 5;
        let isDrawing = false;
        let isPaused = false;
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let fps = 0;

        // Stickmen
        let stickmen = [];
        let activeStickman = 0;
        let keys = {};

        class Stickman {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.width = 5;
                this.height = 12;
                this.onGround = false;
                this.facingRight = true;
                this.walkFrame = 0;
                this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                this.health = 100;
                this.alive = true;
            }

            update(inputKeys = {}) {
                if (!this.alive) return;

                // Stickman is about 4 cells wide and 10 cells tall
                const feetY = Math.floor(this.y) + 10;
                const headY = Math.floor(this.y);
                const leftX = Math.floor(this.x) - 1;
                const rightX = Math.floor(this.x) + 1;
                const centerX = Math.floor(this.x);

                // Check if on ground - check cells directly below feet
                this.onGround = false;
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = centerX + dx;
                    const checkY = feetY + 1;
                    if (inBounds(checkX, checkY)) {
                        const t = grid[idx(checkX, checkY)];
                        if (t !== T.EMPTY && !IS_GAS.has(t) && !IS_LIQUID.has(t)) {
                            this.onGround = true;
                            break;
                        }
                    }
                }
                // Also ground if at bottom of screen
                if (feetY >= HEIGHT - 2) {
                    this.onGround = true;
                }

                // Process input AFTER ground check
                this.control(inputKeys);

                // Apply gravity
                if (!this.onGround) {
                    this.vy += 0.4;
                }
                // Terminal velocity
                if (this.vy > 5) this.vy = 5;

                // Check for hazards around the stickman
                for (let dy = 0; dy <= 10; dy += 2) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const gx = centerX + dx;
                        const gy = headY + dy;
                        if (inBounds(gx, gy)) {
                            const t = grid[idx(gx, gy)];
                            if (t === T.FIRE || t === T.LAVA || t === T.PLASMA) {
                                this.health -= 1;
                            } else if (t === T.ACID) {
                                this.health -= 3;
                            } else if (t === T.POISON) {
                                this.health -= 0.5;
                            } else if (t === T.WATER) {
                                // Swimming - slow down and allow floating
                                this.vy *= 0.85;
                            }
                        }
                    }
                }

                if (this.health <= 0) {
                    this.alive = false;
                    // Create particles on death
                    for (let i = 0; i < 15; i++) {
                        const px = centerX + Math.floor(Math.random() * 4 - 2);
                        const py = headY + Math.floor(Math.random() * 10);
                        if (inBounds(px, py) && grid[idx(px, py)] === T.EMPTY) {
                            grid[idx(px, py)] = T.ASH;
                        }
                    }
                    return;
                }

                // Horizontal movement with step-up logic
                const newX = this.x + this.vx;
                let canMoveX = true;
                let needsStepUp = false;
                let stepUpHeight = 0;
                const checkXPos = Math.floor(newX) + (this.vx > 0 ? 2 : -2);

                // Check for obstacles and determine if we can step up
                if (Math.abs(this.vx) > 0.05) {
                    let obstacleHeight = 0;
                    // Check from feet upward to find obstacle height
                    for (let dy = 10; dy >= 0; dy--) {
                        const gx = checkXPos;
                        const gy = headY + dy;
                        if (inBounds(gx, gy)) {
                            const t = grid[idx(gx, gy)];
                            const isSolid = t !== T.EMPTY && !IS_GAS.has(t) && !IS_LIQUID.has(t);
                            if (isSolid) {
                                obstacleHeight = 10 - dy + 1;
                            }
                        }
                    }

                    // Can step up obstacles up to 5 cells high (allows climbing 45 degree slopes)
                    if (obstacleHeight > 0 && obstacleHeight <= 5) {
                        // Check if there's room above to step up
                        let canStepUp = true;
                        for (let dy = 0; dy < 8; dy++) {
                            const gx = checkXPos;
                            const gy = headY + dy - obstacleHeight;
                            if (inBounds(gx, gy)) {
                                const t = grid[idx(gx, gy)];
                                if (IS_SOLID.has(t)) {
                                    canStepUp = false;
                                    break;
                                }
                            }
                        }
                        if (canStepUp) {
                            needsStepUp = true;
                            stepUpHeight = obstacleHeight;
                        } else {
                            canMoveX = false;
                        }
                    } else if (obstacleHeight > 5) {
                        // Too high to step up - blocked by wall
                        canMoveX = false;
                    }
                }

                if (canMoveX) {
                    this.x = newX;
                    if (needsStepUp) {
                        this.y -= stepUpHeight;
                    }
                } else {
                    this.vx = 0;
                }

                // Push stickman up if embedded in ground (fixes sinking issue)
                let embedded = true;
                while (embedded) {
                    embedded = false;
                    const checkY = Math.floor(this.y) + 10;
                    for (let dx = -1; dx <= 1; dx++) {
                        const gx = Math.floor(this.x) + dx;
                        if (inBounds(gx, checkY)) {
                            const t = grid[idx(gx, checkY)];
                            if (t !== T.EMPTY && !IS_GAS.has(t) && !IS_LIQUID.has(t)) {
                                this.y -= 1;
                                embedded = true;
                                break;
                            }
                        }
                    }
                    // Safety limit
                    if (this.y < 0) {
                        this.y = 0;
                        break;
                    }
                }

                // Vertical movement
                const newY = this.y + this.vy;
                let canMoveY = true;

                if (this.vy > 0) {
                    // Falling - check below feet
                    for (let dx = -1; dx <= 1; dx++) {
                        const gx = centerX + dx;
                        const gy = Math.floor(newY) + 11;
                        if (inBounds(gx, gy)) {
                            const t = grid[idx(gx, gy)];
                            if (t !== T.EMPTY && !IS_GAS.has(t) && !IS_LIQUID.has(t)) {
                                canMoveY = false;
                                this.vy = 0;
                                this.y = gy - 11;
                                this.onGround = true;
                                break;
                            }
                        }
                        // Stop at bottom of screen
                        if (gy >= HEIGHT) {
                            canMoveY = false;
                            this.vy = 0;
                            this.y = HEIGHT - 11;
                            this.onGround = true;
                            break;
                        }
                    }
                } else if (this.vy < 0) {
                    // Jumping - check above head
                    for (let dx = -1; dx <= 1; dx++) {
                        const gx = centerX + dx;
                        const gy = Math.floor(newY);
                        if (inBounds(gx, gy)) {
                            const t = grid[idx(gx, gy)];
                            if (IS_SOLID.has(t)) {
                                canMoveY = false;
                                this.vy = 0;
                                break;
                            }
                        }
                    }
                }

                if (canMoveY) this.y = newY;

                // Bounds
                this.x = Math.max(2, Math.min(WIDTH - 3, this.x));
                this.y = Math.max(0, Math.min(HEIGHT - 11, this.y));

                // Friction
                this.vx *= 0.85;

                // Update walk frame
                if (Math.abs(this.vx) > 0.1) {
                    this.walkFrame = (this.walkFrame + 0.3) % 4;
                } else {
                    this.walkFrame = 0;
                }
            }

            draw(ctx) {
                if (!this.alive) return;

                const px = this.x * CELL_SIZE;
                const py = this.y * CELL_SIZE;
                const scale = CELL_SIZE;

                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;

                // Head
                ctx.beginPath();
                ctx.arc(px, py + 3 * scale, 2.5 * scale, 0, Math.PI * 2);
                ctx.fill();

                // Body
                ctx.beginPath();
                ctx.moveTo(px, py + 5 * scale);
                ctx.lineTo(px, py + 9 * scale);
                ctx.stroke();

                // Arms
                const armSwing = Math.sin(this.walkFrame * Math.PI) * 0.5;
                ctx.beginPath();
                ctx.moveTo(px - 3 * scale, py + (6 + armSwing) * scale);
                ctx.lineTo(px, py + 6 * scale);
                ctx.lineTo(px + 3 * scale, py + (6 - armSwing) * scale);
                ctx.stroke();

                // Legs
                const legSwing = Math.sin(this.walkFrame * Math.PI) * 0.8;
                ctx.beginPath();
                ctx.moveTo(px - 2 * scale, py + (12 + legSwing) * scale);
                ctx.lineTo(px, py + 9 * scale);
                ctx.lineTo(px + 2 * scale, py + (12 - legSwing) * scale);
                ctx.stroke();

                // Health bar
                const healthWidth = 20;
                const healthHeight = 3;
                ctx.fillStyle = '#333';
                ctx.fillRect(px - healthWidth / 2, py - 10, healthWidth, healthHeight);
                ctx.fillStyle = this.health > 50 ? '#0f0' : this.health > 25 ? '#ff0' : '#f00';
                ctx.fillRect(px - healthWidth / 2, py - 10, healthWidth * (this.health / 100), healthHeight);

                // Active indicator
                if (stickmen[activeStickman] === this) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(px, py - 15);
                    ctx.lineTo(px - 5, py - 20);
                    ctx.lineTo(px + 5, py - 20);
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            control(keys) {
                if (!this.alive) return;

                const speed = 1.5;
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    this.vx = -speed;
                    this.facingRight = false;
                    if (this.onGround && Math.random() < 0.1) sound.play('step', 0.1);
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    this.vx = speed;
                    this.facingRight = true;
                    if (this.onGround && Math.random() < 0.1) sound.play('step', 0.1);
                }
                if ((keys['ArrowUp'] || keys['KeyW'] || keys['Space']) && this.onGround) {
                    this.vy = -6;
                    this.onGround = false;
                    sound.play('jump', 0.3);
                }
            }
        }

        // Helpers
        function idx(x, y) { return y * WIDTH + x; }
        function inBounds(x, y) { return x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT; }
        function get(x, y) { return inBounds(x, y) ? grid[idx(x, y)] : T.STONE; }
        function getNext(x, y) { return inBounds(x, y) ? nextGrid[idx(x, y)] : T.STONE; }

        function set(x, y, type) {
            if (!inBounds(x, y)) return;
            const i = idx(x, y);
            nextGrid[i] = type;
            updated[i] = 1;
        }

        function setIfEmpty(x, y, type) {
            if (!inBounds(x, y)) return false;
            const i = idx(x, y);
            if (nextGrid[i] === T.EMPTY && !updated[i]) {
                nextGrid[i] = type;
                updated[i] = 1;
                return true;
            }
            return false;
        }

        function swap(x1, y1, x2, y2) {
            if (!inBounds(x1, y1) || !inBounds(x2, y2)) return false;
            const i1 = idx(x1, y1);
            const i2 = idx(x2, y2);
            if (updated[i1] || updated[i2]) return false;

            const t1 = grid[i1], t2 = grid[i2];
            nextGrid[i1] = t2;
            nextGrid[i2] = t1;
            updated[i1] = updated[i2] = 1;

            const l = lifetime[i1];
            lifetime[i1] = lifetime[i2];
            lifetime[i2] = l;
            return true;
        }

        function isEmpty(x, y) { return get(x, y) === T.EMPTY; }
        function isEmptyNext(x, y) {
            if (!inBounds(x, y)) return false;
            const i = idx(x, y);
            return nextGrid[i] === T.EMPTY && !updated[i];
        }

        function canDisplace(mover, target) {
            if (target === T.EMPTY) return true;
            const md = DENSITY[mover] || 50;
            const td = DENSITY[target] || 50;
            if (IS_POWDER.has(mover) && IS_LIQUID.has(target)) return md > td;
            if (IS_LIQUID.has(mover) && IS_LIQUID.has(target)) return md > td;
            if (IS_GAS.has(mover) && IS_GAS.has(target)) return md > td;
            if (IS_GAS.has(mover) && (IS_LIQUID.has(target) || IS_POWDER.has(target))) return true;
            return false;
        }

        function tryMove(x, y, dx, dy) {
            const nx = x + dx, ny = y + dy;
            if (!inBounds(nx, ny)) return false;
            const i2 = idx(nx, ny);
            if (updated[i2]) return false;

            const type = grid[idx(x, y)];
            const target = grid[i2];

            if (target === T.EMPTY || canDisplace(type, target)) {
                return swap(x, y, nx, ny);
            }
            return false;
        }

        function stayInPlace(x, y) {
            const i = idx(x, y);
            if (!updated[i]) {
                nextGrid[i] = grid[i];
                updated[i] = 1;
            }
        }

        function hasNeighbor(x, y, types) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const t = get(x + dx, y + dy);
                    if (types.has ? types.has(t) : types === t) return true;
                }
            }
            return false;
        }

        function getNeighborOfType(x, y, types) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const t = get(x + dx, y + dy);
                    if (types.has ? types.has(t) : types === t) {
                        return { x: x + dx, y: y + dy, type: t };
                    }
                }
            }
            return null;
        }

        function findPortal(type) {
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    if (grid[idx(x, y)] === type) return { x, y };
                }
            }
            return null;
        }

        function explode(x, y, radius, power = 1) {
            sound.play('explosion', Math.min(0.5, power * 0.3));

            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= radius) {
                        const nx = x + dx, ny = y + dy;
                        if (!inBounds(nx, ny)) continue;
                        const t = get(nx, ny);
                        if (t === T.OBSIDIAN || t === T.VOID || t === T.DIAMOND || t === T.TITANIUM) continue;

                        const chance = (1 - dist / radius) * power;
                        if (Math.random() < chance) {
                            if (IS_EXPLOSIVE.has(t)) {
                                set(nx, ny, T.FIRE);
                            } else if (dist < radius * 0.3) {
                                set(nx, ny, T.EMPTY);
                            } else if (dist < radius * 0.5) {
                                set(nx, ny, Math.random() < 0.5 ? T.FIRE : T.PLASMA);
                            } else if (dist < radius * 0.7) {
                                set(nx, ny, Math.random() < 0.3 ? T.EMBER : T.SMOKE);
                            } else {
                                if (Math.random() < 0.3) set(nx, ny, T.SMOKE);
                            }
                        }
                    }
                }
            }

            // Damage stickmen
            for (const s of stickmen) {
                const dist = Math.sqrt((s.x - x) ** 2 + (s.y - y) ** 2);
                if (dist < radius * 1.5) {
                    s.health -= (radius - dist) * power * 2;
                    s.vx += (s.x - x) / dist * power * 3;
                    s.vy += (s.y - y) / dist * power * 3 - 2;
                }
            }
        }

        // Update functions
        function updatePowder(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (tryMove(x, y, 0, 1)) { if (Math.random() < 0.02) sound.play('sand', 0.05); return; }
            const dir = Math.random() < 0.5 ? -1 : 1;
            if (tryMove(x, y, dir, 1)) return;
            if (tryMove(x, y, -dir, 1)) return;
            stayInPlace(x, y);
        }

        function updateLiquid(x, y, type, spread = 4) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (tryMove(x, y, 0, 1)) { if (Math.random() < 0.01) sound.play('water', 0.03); return; }
            const dir = Math.random() < 0.5 ? -1 : 1;
            if (tryMove(x, y, dir, 1)) return;
            if (tryMove(x, y, -dir, 1)) return;
            for (let s = 1; s <= spread; s++) {
                if (tryMove(x, y, dir * s, 0)) return;
                if (get(x + dir * s, y) !== T.EMPTY) break;
            }
            for (let s = 1; s <= spread; s++) {
                if (tryMove(x, y, -dir * s, 0)) return;
                if (get(x - dir * s, y) !== T.EMPTY) break;
            }
            stayInPlace(x, y);
        }

        function updateGas(x, y, rise = 0.8) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (Math.random() < rise) {
                if (tryMove(x, y, 0, -1)) return;
                const dir = Math.random() < 0.5 ? -1 : 1;
                if (tryMove(x, y, dir, -1)) return;
                if (tryMove(x, y, -dir, -1)) return;
            }
            const dir = Math.random() < 0.5 ? -1 : 1;
            if (Math.random() < 0.3 && tryMove(x, y, dir, 0)) return;
            stayInPlace(x, y);
        }

        // Specific updates
        function updateSnow(x, y) {
            if (hasNeighbor(x, y, HEAT_SOURCE)) { set(x, y, T.WATER); return; }
            updatePowder(x, y);
        }

        function updateGunpowder(x, y) {
            if (hasNeighbor(x, y, HEAT_SOURCE)) { explode(x, y, 8, 1); return; }
            updatePowder(x, y);
        }

        function updateCoal(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (hasNeighbor(x, y, new Set([T.FIRE, T.LAVA]))) {
                lifetime[i]++;
                if (lifetime[i] > 30) {
                    set(x, y, T.FIRE);
                    if (Math.random() < 0.1) sound.play('fire', 0.1);
                    return;
                }
            }
            updatePowder(x, y);
        }

        function updateGlassPowder(x, y) {
            if (hasNeighbor(x, y, new Set([T.LAVA, T.FIRE]))) {
                lifetime[idx(x, y)]++;
                if (lifetime[idx(x, y)] > 50) { set(x, y, T.GLASS); return; }
            }
            updatePowder(x, y);
        }

        function updateEmber(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            lifetime[i]++;
            if (lifetime[i] > 100 || Math.random() < 0.02) {
                set(x, y, Math.random() < 0.3 ? T.ASH : T.EMPTY);
                return;
            }
            const fl = getNeighborOfType(x, y, IS_FLAMMABLE);
            if (fl && Math.random() < 0.1) set(fl.x, fl.y, T.FIRE);
            if (hasNeighbor(x, y, new Set([T.WATER]))) { set(x, y, T.ASH); sound.play('steam', 0.1); return; }
            updatePowder(x, y);
        }

        function updateSalt(x, y) {
            if (hasNeighbor(x, y, new Set([T.WATER])) && Math.random() < 0.02) { set(x, y, T.WATER); return; }
            const pl = getNeighborOfType(x, y, new Set([T.PLANT, T.VINE, T.FUNGUS, T.ALGAE]));
            if (pl && Math.random() < 0.1) set(pl.x, pl.y, T.EMPTY);
            updatePowder(x, y);
        }

        function updateWater(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (hasNeighbor(x, y, new Set([T.LAVA]))) { set(x, y, T.STEAM); sound.play('steam', 0.2); return; }
            const fire = getNeighborOfType(x, y, new Set([T.FIRE, T.EMBER]));
            if (fire) { set(fire.x, fire.y, T.STEAM); }
            const pl = getNeighborOfType(x, y, new Set([T.PLANT, T.SEED, T.ALGAE]));
            if (pl && Math.random() < 0.01) { set(x, y, pl.type === T.ALGAE ? T.ALGAE : T.PLANT); return; }
            updateLiquid(x, y, T.WATER, 5);
        }

        function updateOil(x, y) {
            if (hasNeighbor(x, y, HEAT_SOURCE)) { set(x, y, T.FIRE); sound.play('fire', 0.2); return; }
            updateLiquid(x, y, T.OIL, 4);
        }

        function updateLava(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            const fl = getNeighborOfType(x, y, IS_FLAMMABLE);
            if (fl) set(fl.x, fl.y, T.FIRE);
            const water = getNeighborOfType(x, y, new Set([T.WATER]));
            if (water) { set(water.x, water.y, T.STEAM); sound.play('steam', 0.2); }
            const ice = getNeighborOfType(x, y, new Set([T.ICE, T.SNOW]));
            if (ice) set(ice.x, ice.y, T.WATER);
            if (hasNeighbor(x, y, new Set([T.WATER])) && Math.random() < 0.1) {
                set(x, y, Math.random() < 0.3 ? T.OBSIDIAN : T.STONE);
                return;
            }
            if (Math.random() < 0.05) sound.play('fire', 0.05);
            updateLiquid(x, y, T.LAVA, 2);
        }

        function updateAcid(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const t = get(x + dx, y + dy);
                    if (t !== T.EMPTY && !ACID_IMMUNE.has(t) && !IS_GAS.has(t) && Math.random() < 0.05) {
                        set(x + dx, y + dy, T.EMPTY);
                        sound.play('acid', 0.1);
                        if (Math.random() < 0.3) {
                            set(x, y, Math.random() < 0.5 ? T.GAS : T.EMPTY);
                            return;
                        }
                    }
                }
            }
            updateLiquid(x, y, T.ACID, 4);
        }

        function updatePoison(x, y) {
            const org = getNeighborOfType(x, y, new Set([T.PLANT, T.VINE, T.FUNGUS, T.WOOD, T.ALGAE, T.BACTERIA]));
            if (org && Math.random() < 0.05) set(org.x, org.y, T.EMPTY);
            updateLiquid(x, y, T.POISON, 3);
        }

        function updateMud(x, y) {
            if (!hasNeighbor(x, y, new Set([T.WATER])) && Math.random() < 0.001) { set(x, y, T.DIRT); return; }
            updateLiquid(x, y, T.MUD, 2);
        }

        function updateMercury(x, y) {
            // Very dense liquid
            updateLiquid(x, y, T.MERCURY, 3);
        }

        function updateNitro(x, y) {
            // Explodes on impact
            const i = idx(x, y);
            if (updated[i]) return;
            if (hasNeighbor(x, y, HEAT_SOURCE)) { explode(x, y, 12, 1.5); return; }
            // Check if hit something solid after falling
            if (IS_SOLID.has(get(x, y + 1)) && Math.random() < 0.3) { explode(x, y, 10, 1.2); return; }
            updateLiquid(x, y, T.NITRO, 3);
        }

        function updateFire(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            lifetime[i]++;

            if (lifetime[i] > 50 + Math.random() * 50) {
                set(x, y, Math.random() < 0.2 ? T.SMOKE : T.EMPTY);
                return;
            }

            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const t = get(x + dx, y + dy);
                    if (IS_FLAMMABLE.has(t) && Math.random() < 0.15) {
                        if (IS_EXPLOSIVE.has(t)) {
                            const r = t === T.TNT ? 15 : t === T.C4 ? 25 : t === T.NUKE ? 50 : t === T.NITRO ? 12 : 8;
                            explode(x + dx, y + dy, r, t === T.NUKE ? 2 : 1);
                        } else {
                            set(x + dx, y + dy, T.FIRE);
                        }
                    }
                }
            }

            if (hasNeighbor(x, y, new Set([T.WATER]))) { set(x, y, T.STEAM); return; }
            if (Math.random() < 0.1 && isEmptyNext(x, y - 1)) set(x, y - 1, T.SMOKE);
            if (Math.random() < 0.03) sound.play('fire', 0.05);
            updateGas(x, y, 0.3);
        }

        function updateSteam(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            lifetime[i]++;
            if (lifetime[i] > 200 || (y < 10 && Math.random() < 0.05)) {
                set(x, y, Math.random() < 0.3 ? T.WATER : T.EMPTY);
                return;
            }
            updateGas(x, y, 0.9);
        }

        function updateSmoke(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            lifetime[i]++;
            if (lifetime[i] > 100 || Math.random() < 0.01) { set(x, y, T.EMPTY); return; }
            updateGas(x, y, 0.7);
        }

        function updateToxicGas(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            lifetime[i]++;
            if (hasNeighbor(x, y, HEAT_SOURCE)) { explode(x, y, 10, 1); return; }
            if (lifetime[i] > 300 || Math.random() < 0.005) { set(x, y, T.EMPTY); return; }
            updateGas(x, y, 0.5);
        }

        function updatePlasma(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            lifetime[i]++;
            if (lifetime[i] > 30) { set(x, y, T.FIRE); return; }

            // Plasma melts/ignites everything
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const t = get(x + dx, y + dy);
                    if (t === T.STONE) set(x + dx, y + dy, T.LAVA);
                    else if (t === T.METAL) set(x + dx, y + dy, T.LAVA);
                    else if (t === T.ICE || t === T.SNOW) set(x + dx, y + dy, T.STEAM);
                    else if (IS_FLAMMABLE.has(t)) set(x + dx, y + dy, T.FIRE);
                }
            }
            updateGas(x, y, 0.5);
        }

        function updateLightning(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            sound.play('electric', 0.2);

            // Lightning travels down and spreads through conductors
            let moved = false;
            const dirs = [[0, 1], [-1, 1], [1, 1], [-1, 0], [1, 0]];
            for (const [dx, dy] of dirs) {
                const t = get(x + dx, y + dy);
                if (t === T.EMPTY) {
                    if (Math.random() < 0.3) {
                        set(x + dx, y + dy, T.LIGHTNING);
                        moved = true;
                        break;
                    }
                } else if (IS_CONDUCTIVE.has(t)) {
                    set(x + dx, y + dy, T.LIGHTNING);
                    moved = true;
                    break;
                } else if (IS_FLAMMABLE.has(t)) {
                    set(x + dx, y + dy, T.FIRE);
                }
            }

            set(x, y, T.EMPTY);
        }

        function updateIce(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (hasNeighbor(x, y, HEAT_SOURCE)) { set(x, y, T.WATER); return; }
            const water = getNeighborOfType(x, y, new Set([T.WATER]));
            if (water && Math.random() < 0.02) set(water.x, water.y, T.ICE);
            stayInPlace(x, y);
        }

        function updatePlant(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (hasNeighbor(x, y, new Set([T.FIRE, T.LAVA, T.PLASMA]))) { set(x, y, T.FIRE); return; }
            if (hasNeighbor(x, y, new Set([T.WATER])) && Math.random() < 0.02) {
                const dirs = [[0, -1], [-1, 0], [1, 0], [0, 1]];
                const dir = dirs[Math.floor(Math.random() * dirs.length)];
                if (isEmpty(x + dir[0], y + dir[1])) setIfEmpty(x + dir[0], y + dir[1], T.PLANT);
            }
            stayInPlace(x, y);
        }

        function updateSeed(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            const below = get(x, y + 1);
            if ((below === T.DIRT || below === T.MUD) && hasNeighbor(x, y, new Set([T.WATER])) && Math.random() < 0.05) {
                set(x, y, T.PLANT);
                return;
            }
            updatePowder(x, y);
        }

        function updateVine(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (hasNeighbor(x, y, new Set([T.FIRE, T.LAVA]))) { set(x, y, T.FIRE); return; }
            if (Math.random() < 0.02 && isEmpty(x, y + 1)) setIfEmpty(x, y + 1, T.VINE);
            if (Math.random() < 0.005) {
                const dir = Math.random() < 0.5 ? -1 : 1;
                if (isEmpty(x + dir, y)) setIfEmpty(x + dir, y, T.VINE);
            }
            stayInPlace(x, y);
        }

        function updateFungus(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (hasNeighbor(x, y, new Set([T.FIRE, T.LAVA]))) { set(x, y, T.FIRE); return; }
            if (Math.random() < 0.01) {
                const dirs = [[0, -1], [-1, 0], [1, 0], [0, 1], [-1, -1], [1, -1], [-1, 1], [1, 1]];
                const dir = dirs[Math.floor(Math.random() * dirs.length)];
                const t = get(x + dir[0], y + dir[1]);
                if (t === T.WOOD || t === T.PLANT || t === T.DIRT || t === T.VINE) {
                    set(x + dir[0], y + dir[1], T.FUNGUS);
                }
            }
            stayInPlace(x, y);
        }

        function updateAlgae(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            // Grows in water
            if (hasNeighbor(x, y, new Set([T.WATER])) && Math.random() < 0.02) {
                const water = getNeighborOfType(x, y, new Set([T.WATER]));
                if (water) set(water.x, water.y, T.ALGAE);
            }
            if (hasNeighbor(x, y, new Set([T.FIRE, T.LAVA]))) { set(x, y, T.FIRE); return; }
            stayInPlace(x, y);
        }

        function updateBacteria(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            lifetime[i]++;
            // Bacteria consumes organic matter and spreads
            if (Math.random() < 0.03) {
                const org = getNeighborOfType(x, y, new Set([T.PLANT, T.WOOD, T.VINE, T.FUNGUS]));
                if (org) set(org.x, org.y, T.BACTERIA);
            }
            // Dies eventually
            if (lifetime[i] > 200 || Math.random() < 0.005) { set(x, y, T.EMPTY); return; }
            // Spread to empty
            if (Math.random() < 0.01) {
                const dirs = [[0, -1], [-1, 0], [1, 0], [0, 1]];
                const dir = dirs[Math.floor(Math.random() * dirs.length)];
                if (isEmpty(x + dir[0], y + dir[1])) setIfEmpty(x + dir[0], y + dir[1], T.BACTERIA);
            }
            stayInPlace(x, y);
        }

        function updateFuse(x, y) {
            if (hasNeighbor(x, y, HEAT_SOURCE)) { set(x, y, T.FIRE); return; }
            stayInPlace(x, y);
        }

        function updateTNT(x, y) {
            if (hasNeighbor(x, y, HEAT_SOURCE)) { explode(x, y, 15, 1); return; }
            stayInPlace(x, y);
        }

        function updateC4(x, y) {
            if (hasNeighbor(x, y, HEAT_SOURCE)) { explode(x, y, 25, 1.5); return; }
            stayInPlace(x, y);
        }

        function updateNuke(x, y) {
            if (hasNeighbor(x, y, HEAT_SOURCE)) { explode(x, y, 60, 3); return; }
            stayInPlace(x, y);
        }

        function updateFirework(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (hasNeighbor(x, y, HEAT_SOURCE)) {
                sound.play('firework', 0.3);
                // Launch upward then explode
                for (let py = y - 1; py > y - 30 && py > 0; py--) {
                    if (isEmpty(x, py)) {
                        set(x, py, T.FIRE);
                    } else {
                        // Explode with colors
                        for (let angle = 0; angle < Math.PI * 2; angle += 0.3) {
                            for (let r = 1; r < 10; r++) {
                                const ex = x + Math.floor(Math.cos(angle) * r);
                                const ey = py + Math.floor(Math.sin(angle) * r);
                                if (inBounds(ex, ey) && (isEmpty(ex, ey) || get(ex, ey) === T.SMOKE)) {
                                    set(ex, ey, Math.random() < 0.5 ? T.FIRE : T.EMBER);
                                }
                            }
                        }
                        break;
                    }
                }
                set(x, y, T.EMPTY);
                return;
            }
            stayInPlace(x, y);
        }

        function updateLaser(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            sound.play('laser', 0.2);
            // Laser shoots downward
            for (let ly = y + 1; ly < HEIGHT; ly++) {
                const t = get(x, ly);
                if (t === T.EMPTY) {
                    set(x, ly, T.PLASMA);
                } else if (t === T.GLASS || t === T.DIAMOND) {
                    continue; // Pass through
                } else {
                    if (IS_FLAMMABLE.has(t)) set(x, ly, T.FIRE);
                    else if (t === T.STONE || t === T.BRICK) set(x, ly, T.LAVA);
                    else if (t === T.ICE || t === T.SNOW) set(x, ly, T.STEAM);
                    else if (t === T.METAL) set(x, ly, T.EMBER);
                    break;
                }
            }
            stayInPlace(x, y);
        }

        function updateClone(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const t = get(x + dx, y + dy);
                    if (t !== T.EMPTY && t !== T.CLONE && t !== T.VOID && t !== T.BLACKHOLE && t !== T.WHITEHOLE && Math.random() < 0.1) {
                        const dirs = [[0, -1], [-1, 0], [1, 0], [0, 1]];
                        for (const d of dirs) {
                            if (isEmptyNext(x + d[0], y + d[1])) {
                                set(x + d[0], y + d[1], t);
                                break;
                            }
                        }
                        break;
                    }
                }
            }
            stayInPlace(x, y);
        }

        function updateVoid(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const t = get(x + dx, y + dy);
                    if (t !== T.EMPTY && t !== T.VOID && t !== T.BLACKHOLE) {
                        set(x + dx, y + dy, T.EMPTY);
                    }
                }
            }
            stayInPlace(x, y);
        }

        function updateElectricity(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            sound.play('electric', 0.15);

            // Spread through conductors
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const t = get(x + dx, y + dy);
                    if (IS_CONDUCTIVE.has(t) && Math.random() < 0.3) {
                        set(x + dx, y + dy, T.ELECTRICITY);
                    } else if (IS_FLAMMABLE.has(t) && Math.random() < 0.1) {
                        set(x + dx, y + dy, T.FIRE);
                    }
                }
            }
            set(x, y, T.EMPTY);
        }

        function updateMagnet(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            // Pull metal particles toward it
            const range = 15;
            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx, ny = y + dy;
                    if (!inBounds(nx, ny)) continue;
                    const t = get(nx, ny);
                    if (t === T.METAL || t === T.GRAVEL) {
                        const moveX = dx > 0 ? -1 : dx < 0 ? 1 : 0;
                        const moveY = dy > 0 ? -1 : dy < 0 ? 1 : 0;
                        if (Math.random() < 0.1) tryMove(nx, ny, moveX, moveY);
                    }
                }
            }
            stayInPlace(x, y);
        }

        function updateAntiGravity(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            // Push particles upward in area
            const range = 10;
            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx, ny = y + dy;
                    if (!inBounds(nx, ny)) continue;
                    const t = get(nx, ny);
                    if ((IS_POWDER.has(t) || IS_LIQUID.has(t)) && Math.random() < 0.2) {
                        tryMove(nx, ny, 0, -1);
                    }
                }
            }
            stayInPlace(x, y);
        }

        function updateBlackHole(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            if (Math.random() < 0.1) sound.play('blackhole', 0.2);

            // Pull everything toward center
            const range = 30;
            for (let dy = -range; dy <= range; dy++) {
                for (let dx = -range; dx <= range; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const nx = x + dx, ny = y + dy;
                    if (!inBounds(nx, ny)) continue;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > range) continue;

                    const t = get(nx, ny);
                    if (t === T.EMPTY || t === T.BLACKHOLE || t === T.WHITEHOLE || IS_SOLID.has(t)) continue;

                    const pull = 1 - dist / range;
                    if (Math.random() < pull * 0.3) {
                        const moveX = dx > 0 ? -1 : dx < 0 ? 1 : 0;
                        const moveY = dy > 0 ? -1 : dy < 0 ? 1 : 0;
                        if (dist < 3) {
                            // Consume
                            set(nx, ny, T.EMPTY);
                        } else {
                            tryMove(nx, ny, moveX, moveY);
                        }
                    }
                }
            }
            stayInPlace(x, y);
        }

        function updateWhiteHole(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            // Emit random particles
            if (Math.random() < 0.3) {
                const types = [T.SAND, T.WATER, T.FIRE, T.SMOKE, T.STEAM];
                const type = types[Math.floor(Math.random() * types.length)];
                const dirs = [[0, -1], [-1, 0], [1, 0], [0, 1], [-1, -1], [1, -1], [-1, 1], [1, 1]];
                const dir = dirs[Math.floor(Math.random() * dirs.length)];
                setIfEmpty(x + dir[0], y + dir[1], type);
            }
            stayInPlace(x, y);
        }

        function updatePortalA(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            const dest = findPortal(T.PORTAL_B);
            if (dest) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const t = get(x + dx, y + dy);
                        if (t !== T.EMPTY && t !== T.PORTAL_A && t !== T.PORTAL_B && !IS_SOLID.has(t)) {
                            // Teleport to portal B
                            const destDirs = [[0, -1], [-1, 0], [1, 0], [0, 1]];
                            for (const d of destDirs) {
                                if (isEmptyNext(dest.x + d[0], dest.y + d[1])) {
                                    set(dest.x + d[0], dest.y + d[1], t);
                                    set(x + dx, y + dy, T.EMPTY);
                                    sound.play('portal', 0.2);
                                    break;
                                }
                            }
                            break;
                        }
                    }
                }
            }
            stayInPlace(x, y);
        }

        function updatePortalB(x, y) {
            const i = idx(x, y);
            if (updated[i]) return;
            const dest = findPortal(T.PORTAL_A);
            if (dest) {
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const t = get(x + dx, y + dy);
                        if (t !== T.EMPTY && t !== T.PORTAL_A && t !== T.PORTAL_B && !IS_SOLID.has(t)) {
                            const destDirs = [[0, -1], [-1, 0], [1, 0], [0, 1]];
                            for (const d of destDirs) {
                                if (isEmptyNext(dest.x + d[0], dest.y + d[1])) {
                                    set(dest.x + d[0], dest.y + d[1], t);
                                    set(x + dx, y + dy, T.EMPTY);
                                    sound.play('portal', 0.2);
                                    break;
                                }
                            }
                            break;
                        }
                    }
                }
            }
            stayInPlace(x, y);
        }

        // Main update
        function update() {
            nextGrid.set(grid);
            updated.fill(0);

            for (let y = HEIGHT - 1; y >= 0; y--) {
                const xIndices = [];
                for (let x = 0; x < WIDTH; x++) xIndices.push(x);
                for (let i = xIndices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [xIndices[i], xIndices[j]] = [xIndices[j], xIndices[i]];
                }

                for (const x of xIndices) {
                    const type = grid[idx(x, y)];
                    switch (type) {
                        case T.SAND: case T.DIRT: case T.GRAVEL: case T.ASH: updatePowder(x, y); break;
                        case T.SNOW: updateSnow(x, y); break;
                        case T.GUNPOWDER: updateGunpowder(x, y); break;
                        case T.SALT: updateSalt(x, y); break;
                        case T.EMBER: updateEmber(x, y); break;
                        case T.COAL: updateCoal(x, y); break;
                        case T.GLASS_POWDER: updateGlassPowder(x, y); break;
                        case T.WATER: updateWater(x, y); break;
                        case T.OIL: updateOil(x, y); break;
                        case T.LAVA: updateLava(x, y); break;
                        case T.ACID: updateAcid(x, y); break;
                        case T.POISON: updatePoison(x, y); break;
                        case T.MUD: updateMud(x, y); break;
                        case T.MERCURY: updateMercury(x, y); break;
                        case T.NITRO: updateNitro(x, y); break;
                        case T.STONE: case T.WOOD: case T.METAL: case T.GLASS: case T.BRICK: case T.OBSIDIAN: case T.DIAMOND: case T.TITANIUM: stayInPlace(x, y); break;
                        case T.ICE: updateIce(x, y); break;
                        case T.FIRE: updateFire(x, y); break;
                        case T.STEAM: updateSteam(x, y); break;
                        case T.SMOKE: updateSmoke(x, y); break;
                        case T.GAS: updateToxicGas(x, y); break;
                        case T.PLASMA: updatePlasma(x, y); break;
                        case T.LIGHTNING: updateLightning(x, y); break;
                        case T.PLANT: updatePlant(x, y); break;
                        case T.SEED: updateSeed(x, y); break;
                        case T.VINE: updateVine(x, y); break;
                        case T.FUNGUS: updateFungus(x, y); break;
                        case T.ALGAE: updateAlgae(x, y); break;
                        case T.BACTERIA: updateBacteria(x, y); break;
                        case T.FUSE: updateFuse(x, y); break;
                        case T.TNT: updateTNT(x, y); break;
                        case T.C4: updateC4(x, y); break;
                        case T.NUKE: updateNuke(x, y); break;
                        case T.FIREWORK: updateFirework(x, y); break;
                        case T.LASER: updateLaser(x, y); break;
                        case T.CLONE: updateClone(x, y); break;
                        case T.VOID: updateVoid(x, y); break;
                        case T.ELECTRICITY: updateElectricity(x, y); break;
                        case T.MAGNET: updateMagnet(x, y); break;
                        case T.ANTIGRAVITY: updateAntiGravity(x, y); break;
                        case T.BLACKHOLE: updateBlackHole(x, y); break;
                        case T.WHITEHOLE: updateWhiteHole(x, y); break;
                        case T.PORTAL_A: updatePortalA(x, y); break;
                        case T.PORTAL_B: updatePortalB(x, y); break;
                    }
                }
            }

            [grid, nextGrid] = [nextGrid, grid];

            // Update stickmen
            for (const s of stickmen) s.update(s === stickmen[activeStickman] ? keys : {});
            stickmen = stickmen.filter(s => s.alive || s.health > -100);
        }

        // Render
        function render() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const type = grid[idx(x, y)];
                    if (type === T.EMPTY) continue;

                    const colors = COLORS[type];
                    if (!colors) continue;

                    let colorIdx = (x * 7 + y * 13) % colors.length;
                    if (type === T.FIRE || type === T.PLASMA || type === T.LIGHTNING || type === T.ELECTRICITY) {
                        colorIdx = (colorIdx + frameCount) % colors.length;
                    }
                    const color = colors[colorIdx];

                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);

                    for (let py = 0; py < CELL_SIZE; py++) {
                        for (let px = 0; px < CELL_SIZE; px++) {
                            const pixelIdx = ((y * CELL_SIZE + py) * canvas.width + (x * CELL_SIZE + px)) * 4;
                            data[pixelIdx] = r;
                            data[pixelIdx + 1] = g;
                            data[pixelIdx + 2] = b;
                            data[pixelIdx + 3] = 255;
                        }
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw stickmen
            for (const s of stickmen) s.draw(ctx);
        }

        // Drawing
        function draw(canvasX, canvasY) {
            const gridX = Math.floor(canvasX / CELL_SIZE);
            const gridY = Math.floor(canvasY / CELL_SIZE);

            if (currentType === T.STICKMAN) {
                // Create stickman
                if (stickmen.length < 10) {
                    const newStickman = new Stickman(gridX, gridY);
                    stickmen.push(newStickman);
                    activeStickman = stickmen.length - 1;
                }
                return;
            }

            for (let dy = -brushSize + 1; dy < brushSize; dy++) {
                for (let dx = -brushSize + 1; dx < brushSize; dx++) {
                    if (dx * dx + dy * dy < brushSize * brushSize) {
                        const x = gridX + dx;
                        const y = gridY + dy;
                        if (inBounds(x, y)) {
                            if (currentType === T.EMPTY || grid[idx(x, y)] === T.EMPTY) {
                                grid[idx(x, y)] = currentType;
                                lifetime[idx(x, y)] = 0;
                            }
                        }
                    }
                }
            }
        }

        // Events
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            draw(e.clientX - rect.left, e.clientY - rect.top);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                draw(e.clientX - rect.left, e.clientY - rect.top);
            }
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            brushSize = Math.max(1, Math.min(25, brushSize - Math.sign(e.deltaY)));
            document.getElementById('brush-slider').value = brushSize;
            document.getElementById('brush-value').textContent = brushSize;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            draw(touch.clientX - rect.left, touch.clientY - rect.top);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                draw(touch.clientX - rect.left, touch.clientY - rect.top);
            }
        });

        canvas.addEventListener('touchend', () => isDrawing = false);

        // Buttons
        document.querySelectorAll('[data-type]').forEach(btn => {
            btn.addEventListener('click', function () {
                currentType = T[this.dataset.type];
                document.querySelectorAll('[data-type]').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
            });
        });

        document.getElementById('btn-clear').addEventListener('click', () => {
            grid.fill(T.EMPTY);
            lifetime.fill(0);
            stickmen = [];
        });

        document.getElementById('brush-slider').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brush-value').textContent = brushSize;
        });

        document.getElementById('pause-toggle').addEventListener('change', (e) => {
            isPaused = e.target.checked;
        });

        document.getElementById('sound-toggle').addEventListener('change', (e) => {
            sound.enabled = e.target.checked;
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            // Space for jumping - always prevent default to avoid page scroll
            if (e.code === 'Space') {
                e.preventDefault();
            }

            // P key for pause
            if (e.code === 'KeyP') {
                isPaused = !isPaused;
                document.getElementById('pause-toggle').checked = isPaused;
            }

            // Tab to switch stickmen
            if (e.code === 'Tab') {
                e.preventDefault();
                if (stickmen.length > 0) {
                    activeStickman = (activeStickman + 1) % stickmen.length;
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Stats
        function updateStats() {
            let count = 0;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i] !== T.EMPTY) count++;
            }
            const aliveStickmen = stickmen.filter(s => s.alive).length;
            document.getElementById('stats').textContent = `Particles: ${count} | Stickmen: ${aliveStickmen} | FPS: ${fps}`;
        }

        // Game loop
        function gameLoop() {
            frameCount++;

            if (!isPaused) {
                update();
            }
            render();

            const now = performance.now();
            if (now - lastFpsTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsTime = now;
                updateStats();
            }

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
